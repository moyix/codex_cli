#!/usr/bin/env python

import codecs
from enum import Enum
import os
import re
import math
import subprocess
import signal
import openai
import socket
import selectors
import argparse
import time
from datetime import datetime
import sys
import random
import logging as logmodule
import atexit
from collections import defaultdict
from transformers import GPT2TokenizerFast
from colorama import init as colorama_init, Fore, Style
colorama_init()

def close_qemu():
    global qemu_proc
    if qemu_proc:
        qemu_proc.send_signal(signal.SIGINT)
        qemu_proc.wait()
        qemu_proc = None
atexit.register(close_qemu)

# Debug: print out the transcript of the conversation so far
# when Control-C is pressed
def sigint_handler(signum, frame):
    global conversation
    print(conversation)
    sys.exit(0)
signal.signal(signal.SIGINT, sigint_handler)

BASENAME = os.path.dirname(os.path.realpath(__file__))
DEFAULT_KEY_PATH = os.path.join(BASENAME, 'openai.key')
DEFAULT_QCOW = '/home/moyix/.panda/bionic-server-cloudimg-amd64-noaslr-nokaslr.qcow2'
DEFAULT_SNAPSHOT = 'bootroot'

engine_tokens = {
    'code-davinci-001': 4096,
    'code-cushman-001': 2048,
}

parser = argparse.ArgumentParser(description='Run Codex on a QEMU instance.')
parser.add_argument('-t', '--temperature', type=float, default=0.8, help='Temperature for the model.')
parser.add_argument('-f', '--frequency', type=float, default=1.0, help='Frequency penalty for the model (-2.0 - 2.0).')
parser.add_argument('-e', '--engine', type=str, default='code-davinci-001', choices=list(engine_tokens.keys()), help='Engine to use.')
parser.add_argument('-n', '--num-responses', type=int, default=10, help='Number of responses to generate.')
parser.add_argument('-k', '--key', type=str, default=DEFAULT_KEY_PATH, help='Path to the OpenAI API key.')
parser.add_argument('-p', '--port', type=int, default=3456, help='Port to connect to.')
parser.add_argument('-w', '--whole-context', action='store_true', help='Use the whole conversation as context.')
parser.add_argument('-q', '--qcow', type=str, default=DEFAULT_QCOW, help='Path to the QEMU image.')
parser.add_argument('-s', '--snapshot', type=str, default=DEFAULT_SNAPSHOT, help='Snapshot to boot from.')
parser.add_argument('-d', '--debug', action='store_true', help='Enable debug mode.')
parser.add_argument('-l', '--log', type=str, default='', help='Path to the log file.')
parser.add_argument('--timeout', type=int, default=5, help='How long to wait for a response from QEMU.')
args = parser.parse_args()

openai.api_key_path = args.key
MAX_TOKENS = engine_tokens[args.engine] - 128
TIMEOUT = args.timeout

QEMU_CMD = [
    'qemu-system-x86_64',
    '-m', '1G', 
    '-hda', args.qcow,
    '-machine', 'accel=kvm',
    '-serial', f'tcp:localhost:{args.port},server,nowait,nodelay',
    '-display', 'none',
    '-net', 'nic', '-net', 'user', '-loadvm', args.snapshot,
]

# Set up logging
loglevel = logmodule.DEBUG if args.debug else logmodule.INFO
logfile = open(args.log, 'a') if args.log else None
logger = logmodule.getLogger("CodexCLI")
logger.setLevel(loglevel)
ch = logmodule.StreamHandler(logfile)
ch.setLevel(loglevel)
formatter = logmodule.Formatter('[%(asctime)s] %(levelname)s: %(message)s')
ch.setFormatter(formatter)
logger.handlers = [ch]

# Constants for tracking sides of conversation
class Participant(Enum):
    Codex  = 1  # Something generated by Codex
    QEMU   = 2  # Something received from QEMU
    Manual = 3  # Something manually created by this script and sent to QEMU
    def __str__(self):
        return self.name
    
    def color(self):
        return {
            Participant.Codex: Fore.RED,
            Participant.QEMU: Style.RESET_ALL,
            Participant.Manual: Fore.YELLOW,
        }[self]

# Class for keeping track of a conversation between Codex and QEMU
class Conversation:
    def __init__(self, sock, whole_conversation=False):
        self.whole_conversation = whole_conversation
        self.trimmed_context = ''
        self.last_response = ''
        self.last_sent = ''
        self.log = []
        self.tok = GPT2TokenizerFast(os.path.join(BASENAME, 'tokenizer.json'),
                                     os.path.join(BASENAME, 'vocab.bpe'))

        self.socket = sock
        self.sel = selectors.DefaultSelector()
        self.sel.register(self.socket, selectors.EVENT_READ)

    def trim_prompt(self, s):
        tokens = self.tok.encode(s)
        if len(tokens) > MAX_TOKENS:
            return self.tok.decode(tokens[-MAX_TOKENS:])
        else:
            return s

    def update(self, data, participant):
        self.last_response = data
        self.trimmed_context = self.trim_prompt(self.trimmed_context + data)
        self.log.append((datetime.now(), participant, data))

    def __str__(self):
        s = ("\n\n" +
            "Transcript:\n" + 
            "==========\n")
        for t, p, r in self.log:
            s += f'[{t}] <{p:6}> {repr(r)}\n'
        s += "==========\n\n"
        return s 

    def __repr__(self):
        return f"<Conversation: {len(self.log)} entries>"

    def prompt(self):
        if self.whole_conversation:
            return self.trimmed_context
        else:
            return self.trim_prompt(self.last_response)

    def participant_print(self, s, p):
        if not s: return
        sys.stdout.write(p.color() + s + Style.RESET_ALL)
        sys.stdout.flush()

    # Regex to see if we have a command prompt
    cmd_prompt_re = re.compile(br'\w+@ubuntu:[^#$]+[#$] $')
    # Receive all data from QEMU. Stops when we get a command prompt or after
    # TIMEOUT seconds.
    def recv(self):
        all_data = b''
        events = self.sel.select(timeout=TIMEOUT)
        last_sent_bytes = self.last_sent.encode('utf8')

        # Do incremental decoding here so that we can print the output as it
        # comes in. Annoying because we don't actually have any guarantee that
        # this is actually going to be UTF8.
        dec = codecs.getincrementaldecoder('utf8')()
        def try_unicode(b):
            nonlocal dec
            try:
                pr_data = dec.decode(b)
            except UnicodeDecodeError:
                pr_data = (dec.get_state()[0]+b).decode('utf8', 'ignore')
                # Reset the decoder
                dec = codecs.getincrementaldecoder('utf8')()
            return pr_data

        while events:
            for key, mask in events:
                data = key.fileobj.recv(1024)
                logger.debug(f'recv: {repr(data)}')
                if last_sent_bytes:
                    # Gobble up as much of the echo as we can
                    while last_sent_bytes and data and data[0] == last_sent_bytes[0]:
                        last_sent_bytes = last_sent_bytes[1:]
                        data = data[1:]
                if data:
                    all_data += data
                    self.participant_print(try_unicode(data), Participant.QEMU)
            # Break early if we have a prompt
            lines = all_data.splitlines()
            if lines and self.cmd_prompt_re.match(lines[-1]) is not None:
                break
            events = self.sel.select(timeout=TIMEOUT)

        # Wait until we have all the data to decode it in case a multibyte
        # character is split across multiple packets.
        all_data = all_data.decode('utf-8',errors='ignore')
        self.update(all_data, Participant.QEMU)
        return all_data

    # Send data to QEMU
    def send(self, s, sender=Participant.Codex):
        self.participant_print(s, sender)
        logger.debug(f'send: {repr(s)}')
        self.socket.sendall(s.encode('utf-8'))
        self.update(s, sender)
        # Save the last sent message so that we can gobble up echo.
        # Echo will use CRLF, so add it here.
        self.last_sent = s.replace('\n', '\r\n')

    def __del__(self):
        self.sel.unregister(self.socket)
        self.socket.close()

class CodexResponse:
    # Helper to strip ANSI codes from a string
    ansi_escape = re.compile(r'(?:\x1B[@-_]|[\x80-\x9F])[0-?]*[ -/]*[@-~]')
    cr_to_nl = re.compile(r'\r+', re.MULTILINE)

    def __init__(self, engine, temperature, frequency_penalty, num_responses):
        self.engine = engine
        self.temperature = temperature
        self.frequency_penalty = frequency_penalty
        self.num_responses = num_responses
        self.responses = []
        self.responses_used = defaultdict(int)

    # Choose a random response, weighted by how much we have used it before
    def choose_response(self, choices):
        texts = [c['text'] for c in choices]
        resp_freq = [ self.responses_used[t] for t in texts ]
        weights = [ math.exp(-f) for f in resp_freq ]
        logger.debug(f'Choosing response from {dict(zip(texts,weights))}')
        return random.choices(texts, weights=weights)[0]
    CONTROL_CHARS = str.maketrans(dict.fromkeys([
        '\x00', # NUL '\0' (null character)
        '\x01', # SOH (start of heading)
        '\x02', # STX (start of text)
        '\x03', # ETX (end of text)
        '\x04', # EOT (end of transmission)
        '\x05', # ENQ (enquiry)
        '\x06', # ACK (acknowledge)
        '\x07', # BEL '\a' (bell)
        '\x08', # BS  '\b' (backspace)
        '\x09', # HT  '\t' (horizontal tab)
        '\x0C', # FF  '\f' (form feed)
        '\x0E', # SO  (shift out)
        '\x0F', # SI  (shift in)
        '\x10', # DLE (data link escape)
        '\x11', # DC1 (device control 1)
        '\x12', # DC2 (device control 2)
        '\x13', # DC3 (device control 3)
        '\x14', # DC4 (device control 4)
        '\x15', # NAK (negative ack.)
        '\x16', # SYN (synchronous idle)
        '\x17', # ETB (end of trans. blk)
        '\x18', # CAN (cancel)
        '\x19', # EM  (end of medium)
        '\x1A', # SUB (substitute)
        '\x1B', # ESC (escape)
        '\x1C', # FS  (file separator)
        '\x1D', # GS  (group separator)
        '\x1E', # RS  (record separator)
        '\x1F', # US  (unit separator)
    ]))
    @classmethod
    def clean_prompt(cls, prompt):
        # Strip ANSI sequences (e.g. colors)
        prompt = cls.ansi_escape.sub('', prompt)
        # Replace \r\n with \n
        prompt = prompt.replace('\r\n', '\n')
        # If there are strings of \r left, coalesce them into \n
        prompt = cls.cr_to_nl.sub('\n', prompt)
        # Strip ASCII control characters
        prompt = prompt.translate(cls.CONTROL_CHARS)
        return prompt

    def get_next_response(self, prompt):
        prompt = self.clean_prompt(prompt)
        logger.debug(f'Getting next response for prompt: {repr(prompt)}')
        response = openai.Completion.create(
            engine=self.engine,
            echo=False,
            prompt=prompt,
            temperature=self.temperature,
            frequency_penalty=self.frequency_penalty,
            max_tokens=128,
            top_p=1.0,
            stop = '\n',
            n = self.num_responses,
        )
        r = self.choose_response(response['choices'])
        logger.debug(f'Codex chose {repr(r)}, previously used {self.responses_used[r]} time(s)')
        self.responses_used[r] += 1
        return r.rstrip() + '\n'

# Launch the VM
logger.debug(f"Starting QEMU with command: {' '.join(QEMU_CMD)}")
qemu_proc = subprocess.Popen(QEMU_CMD)
# Connect to it
while True:
    try:
        logger.debug(f"Connecting to QEMU on port {args.port}")
        sock = socket.create_connection(('localhost', args.port), timeout=1)
        sock.setblocking(False)
        break
    except:
        logger.debug(f"Connect failed, retrying...")
        time.sleep(1)
logger.debug(f"Connected to QEMU")

conversation = Conversation(sock, args.whole_context)
codex = CodexResponse(
    engine=args.engine,
    temperature=args.temperature,
    frequency_penalty=args.frequency,
    num_responses=args.num_responses,
)
logger.debug(f"Created CodexResponse(engine={args.engine}, temp={args.temperature}, freq={args.frequency}, n={args.num_responses}")

# Hit enter to start things off
conversation.send('\n', Participant.Manual)
conversation.recv()
# Main loop: read from QEMU, send to Codex, read from Codex, send to QEMU
while True:
    prompt = conversation.prompt()
    resp = codex.get_next_response(prompt)
    conversation.send(resp)
    conversation.recv()
